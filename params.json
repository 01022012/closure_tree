{"name":"Closure tree","tagline":"Easily and efficiently make your ActiveRecord model support hierarchies","body":"# Closure Tree [![Build Status](https://secure.travis-ci.org/mceachen/closure_tree.png?branch=master)](http://travis-ci.org/mceachen/closure_tree)\r\n\r\n### Closure_tree lets your ActiveRecord models act as nodes in a [tree data structure](http://en.wikipedia.org/wiki/Tree_%28data_structure%29)\r\n\r\nCommon applications include modeling hierarchical data, like tags, page graphs in CMSes,\r\nand tracking user referrals.\r\n\r\nMostly API-compatible with other popular nesting gems for Rails, like\r\n[ancestry](https://github.com/stefankroes/ancestry),\r\n[acts_as_tree](https://github.com/amerine/acts_as_tree) and\r\n[awesome_nested_set](https://github.com/collectiveidea/awesome_nested_set/),\r\nclosure_tree has some great features:\r\n\r\n* __Best-in-class select performance__:\r\n  * Fetch your whole ancestor lineage in 1 SELECT.\r\n  * Grab all your descendants: 1 SELECT.\r\n  * Get all your siblings: 1 SELECT.\r\n  * Fetch all [7-degrees-of-bacon in a nested hash](#nested-hashes): 1 SELECT.\r\n* __Best-in-class mutation performance__:\r\n  * 2 SQL INSERTs on node creation\r\n  * 3 SQL INSERT/UPDATEs on node reparenting\r\n* Support for reparenting children (and all their progeny)\r\n* Support for [concurrency](#concurrency) (using [with_advisory_lock](https://github/mceachen/with_advisory_lock))\r\n* Support for polymorphism [STI](#sti) within the hierarchy\r\n* ```find_or_create_by_path``` for [building out hierarchies quickly and conveniently](#find_or_create_by_path)\r\n* Support for [deterministic ordering](#deterministic-ordering) of children\r\n* Support for [preordered](http://en.wikipedia.org/wiki/Tree_traversal#Pre-order) traversal of descendants\r\n* Support for single-select depth-limited [nested hashes](#nested-hashes)\r\n* Excellent [test coverage](#testing) in a variety of environments\r\n\r\nSee [Bill Karwin](http://karwin.blogspot.com/)'s excellent\r\n[Models for hierarchical data presentation](http://www.slideshare.net/billkarwin/models-for-hierarchical-data)\r\nfor a description of different tree storage algorithms.\r\n\r\n## Table of Contents\r\n\r\n- [Installation](#installation)\r\n- [Usage](#usage)\r\n- [Accessing Data](#accessing-data)\r\n- [Polymorphic hierarchies with STI](#polymorphic-hierarchies-with-sti)\r\n- [Deterministic ordering](#deterministic-ordering)\r\n- [Concurrency](#concurrency)\r\n- [FAQ](#faq)\r\n- [Testing](#testing)\r\n- [Change log](#change-log)\r\n\r\n## Installation\r\n\r\nNote that closure_tree only supports Rails 3.0 and later, and has test coverage for MySQL, PostgreSQL, and SQLite.\r\n\r\n1.  Add this to your Gemfile: ```gem 'closure_tree'```\r\n\r\n2.  Run ```bundle install```\r\n\r\n3.  Add ```acts_as_tree``` to your hierarchical model(s). There are a number of [options](#available-options) you can pass in, too.\r\n\r\n4.  Add a migration to add a ```parent_id``` column to the model you want to act_as_tree.\r\n    You may want to also [add a column for deterministic ordering of children](#sort_order), but that's optional.\r\n\r\n    ```ruby\r\n    class AddParentIdToTag < ActiveRecord::Migration\r\n      def change\r\n        add_column :tag, :parent_id, :integer\r\n      end\r\n    end\r\n    ```\r\n\r\n    Note that if the column is null, the tag will be considered a root node.\r\n\r\n5.  Add a database migration to store the hierarchy for your model. By\r\n    default the table name will be the model's table name, followed by\r\n    \"_hierarchies\". Note that by calling ```acts_as_tree```, a \"virtual model\" (in this case, ```TagHierarchy```)\r\n    will be added automatically, so you don't need to create it.\r\n\r\n    ```ruby\r\n    class CreateTagHierarchies < ActiveRecord::Migration\r\n      def change\r\n        create_table :tag_hierarchies, :id => false do |t|\r\n          t.integer  :ancestor_id, :null => false   # ID of the parent/grandparent/great-grandparent/... tag\r\n          t.integer  :descendant_id, :null => false # ID of the target tag\r\n          t.integer  :generations, :null => false   # Number of generations between the ancestor and the descendant. Parent/child = 1, for example.\r\n        end\r\n\r\n        # For \"all progeny of…\" selects:\r\n        add_index :tag_hierarchies, [:ancestor_id, :descendant_id], :unique => true\r\n\r\n        # For \"all ancestors of…\" selects\r\n        add_index :tag_hierarchies, [:descendant_id]\r\n      end\r\n    end\r\n    ```\r\n\r\n6.  Run ```rake db:migrate```\r\n\r\n7.  If you're migrating from another system where your model already has a\r\n    ```parent_id``` column, run ```Tag.rebuild!``` and the\r\n    …_hierarchy table will be truncated and rebuilt.\r\n\r\n    If you're starting from scratch you don't need to call ```rebuild!```.\r\n\r\n## Usage\r\n\r\n### Creation\r\n\r\nCreate a root node:\r\n\r\n```ruby\r\ngrandparent = Tag.create(:name => 'Grandparent')\r\n```\r\n\r\nChild nodes are created by appending to the children collection:\r\n\r\n```ruby\r\nparent = grandparent.children.create(:name => 'Parent')\r\n```\r\n\r\nOr by giving the parent to the constructor:\r\n\r\n```ruby\r\nchild1 = Tag.create(:name => 'First Child', :parent => parent)\r\n```\r\n\r\nOr by appending to the children collection:\r\n\r\n```ruby\r\nchild2 = Tag.new(:name => 'Second Child')\r\nparent.children << child2\r\n```\r\n\r\nOr by calling the \"add_child\" method:\r\n\r\n```ruby\r\nchild3 = Tag.new(:name => 'Third Child')\r\nparent.add_child child3\r\n```\r\n\r\nThen:\r\n\r\n```ruby\r\ngrandparent.self_and_descendants.collect(&:name)\r\n=> [\"Grandparent\", \"Parent\", \"First Child\", \"Second Child\", \"Third Child\"]\r\n\r\nchild1.ancestry_path\r\n=> [\"Grandparent\", \"Parent\", \"First Child\"]\r\n```\r\n\r\n### find_or_create_by_path\r\n\r\nWe can do all the node creation and add_child calls with one method call:\r\n\r\n```ruby\r\nchild = Tag.find_or_create_by_path([\"grandparent\", \"parent\", \"child\"])\r\n```\r\n\r\nYou can ```find``` as well as ```find_or_create``` by \"ancestry paths\".\r\nAncestry paths may be built using any column in your model. The default\r\ncolumn is ```name```, which can be changed with the :name_column option\r\nprovided to ```acts_as_tree```.\r\n\r\nNote that any other AR fields can be set with the second, optional ```attributes``` argument.\r\n\r\n```ruby\r\nchild = Tag.find_or_create_by_path(%w{home chuck Photos\"}, {:tag_type => \"File\"})\r\n```\r\nThis will pass the attribute hash of ```{:name => \"home\", :tag_type => \"File\"}``` to\r\n```Tag.find_or_create_by_name``` if the root directory doesn't exist (and\r\n```{:name => \"chuck\", :tag_type => \"File\"}``` if the second-level tag doesn't exist, and so on).\r\n\r\n### Moving nodes around the tree\r\n\r\nNodes can be moved around to other parents, and closure_tree moves the node's descendancy to the new parent for you:\r\n\r\n```ruby\r\nd = Tag.find_or_create_by_path %w(a b c d)\r\nh = Tag.find_or_create_by_path %w(e f g h)\r\ne = h.root\r\nd.add_child(e) # \"d.children << e\" would work too, of course\r\nh.ancestry_path\r\n=> [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\"]\r\n```\r\n\r\n### Nested hashes\r\n\r\n```hash_tree``` provides a method for rendering a subtree as an\r\nordered nested hash:\r\n\r\n```ruby\r\nb = Tag.find_or_create_by_path %w(a b)\r\na = b.parent\r\nb2 = Tag.find_or_create_by_path %w(a b2)\r\nd1 = b.find_or_create_by_path %w(c1 d1)\r\nc1 = d1.parent\r\nd2 = b.find_or_create_by_path %w(c2 d2)\r\nc2 = d2.parent\r\n\r\nTag.hash_tree\r\n=> {a => {b => {c1 => {d1 => {}}, c2 => {d2 => {}}}, b2 => {}}}\r\n\r\nTag.hash_tree(:limit_depth => 2)\r\n=> {a => {b => {}, b2 => {}}}\r\n\r\nb.hash_tree\r\n=> {b => {c1 => {d1 => {}}, c2 => {d2 => {}}}}\r\n\r\nb.hash_tree(:limit_depth => 2)\r\n=> {b => {c1 => {}, c2 => {}}}\r\n```\r\n\r\n**If your tree is large (or might become so), use :limit_depth.**\r\n\r\nWithout this option, ```hash_tree``` will load the entire contents of that table into RAM. Your\r\nserver may not be happy trying to do this.\r\n\r\nHT: [ancestry](https://github.com/stefankroes/ancestry#arrangement) and [elhoyos](https://github.com/mceachen/closure_tree/issues/11)\r\n\r\n### <a id=\"options\"></a>Available options\r\n\r\nWhen you include ```acts_as_tree``` in your model, you can provide a hash to override the following defaults:\r\n\r\n* ```:parent_column_name``` to override the column name of the parent foreign key in the model's table. This defaults to \"parent_id\".\r\n* ```:hierarchy_table_name``` to override the hierarchy class name. This defaults to the singular name of the model + \"Hierarchy\", like ```TagHierarchy```.\r\n* ```:hierarchy_table_name``` to override the hierarchy table name. This defaults to the singular name of the model + \"_hierarchies\", like ```tag_hierarchies```.\r\n* ```:dependent``` determines what happens when a node is destroyed. Defaults to ```nullify```.\r\n    * ```:nullify``` will simply set the parent column to null. Each child node will be considered a \"root\" node. This is the default.\r\n    * ```:delete_all``` will delete all descendant nodes (which circumvents the destroy hooks)\r\n    * ```:destroy``` will destroy all descendant nodes (which runs the destroy hooks on each child node)\r\n* ```:name_column``` used by #```find_or_create_by_path```, #```find_by_path```, and ```ancestry_path``` instance methods. This is primarily useful if the model only has one required field (like a \"tag\").\r\n* ```:order``` used to set up [deterministic ordering](#deterministic-ordering)\r\n\r\n## Accessing Data\r\n\r\n### Class methods\r\n\r\n* ```Tag.root``` returns an arbitrary root node\r\n* ```Tag.roots``` returns all root nodes\r\n* ```Tag.leaves``` returns all leaf nodes\r\n* ```Tag.hash_tree``` returns an [ordered, nested hash](#nested-hashes) that can be depth-limited.\r\n* ```Tag.find_by_path(path)``` returns the node whose name path is ```path```. See (#find_or_create_by_path).\r\n* ```Tag.find_or_create_by_path(path)``` returns the node whose name path is ```path```, and will create the node if it doesn't exist already.See (#find_or_create_by_path).\r\n* ```Tag.find_all_by_generation(generation_level)``` returns the descendant nodes who are ```generation_level``` away from a root. ```Tag.find_all_by_generation(0)``` is equivalent to ```Tag.roots```.\r\n\r\n### Instance methods\r\n\r\n* ```tag.root``` returns the root for this node\r\n* ```tag.root?``` returns true if this is a root node\r\n* ```tag.child?``` returns true if this is a child node. It has a parent.\r\n* ```tag.leaf?``` returns true if this is a leaf node. It has no children.\r\n* ```tag.leaves``` is scoped to all leaf nodes in self_and_descendants.\r\n* ```tag.depth``` returns the depth, or \"generation\", for this node in the tree. A root node will have a value of 0.\r\n* ```tag.parent``` returns the node's immediate parent. Root nodes will return nil.\r\n* ```tag.children``` is a ```has_many``` of immediate children (just those nodes whose parent is the current node).\r\n* ```tag.ancestors``` is a ordered scope of [ parent, grandparent, great grandparent, … ]. Note that the size of this array will always equal ```tag.depth```.\r\n* ```tag.ancestor_ids``` is an array of the IDs of the ancestors.\r\n* ```tag.self_and_ancestors``` returns a scope containing self, parent, grandparent, great grandparent, etc.\r\n* ```tag.siblings``` returns a scope containing all nodes with the same parent as ```tag```, excluding self.\r\n* ```tag.sibling_ids``` returns an array of the IDs of the siblings.\r\n* ```tag.self_and_siblings``` returns a scope containing all nodes with the same parent as ```tag```, including self.\r\n* ```tag.descendants``` returns a scope of all children, childrens' children, etc., excluding self ordered by depth.\r\n* ```tag.descendant_ids``` returns an array of the IDs of the descendants.\r\n* ```tag.self_and_descendants``` returns a scope of all children, childrens' children, etc., including self, ordered by depth.\r\n* ```tag.hash_tree``` returns an [ordered, nested hash](#nested-hashes) that can be depth-limited.\r\n* ```tag.find_by_path(path)``` returns the node whose name path *from ```tag```* is ```path```. See (#find_or_create_by_path).\r\n* ```tag.find_or_create_by_path(path)``` returns the node whose name path *from ```tag```* is ```path```, and will create the node if it doesn't exist already.See (#find_or_create_by_path).\r\n* ```tag.find_all_by_generation(generation_level)``` returns the descendant nodes who are ```generation_level``` away from ```tag```.\r\n    * ```tag.find_all_by_generation(0).to_a``` == ```[tag]```\r\n    * ```tag.find_all_by_generation(1)``` == ```tag.children```\r\n    * ```tag.find_all_by_generation(2)``` will return the tag's grandchildren, and so on.\r\n* ```tag.destroy``` will destroy a node and do <em>something</em> to its children, which is determined by the ```:dependent``` option passed to ```acts_as_tree```.\r\n\r\n## Polymorphic hierarchies with STI\r\n\r\nPolymorphic models using single table inheritance (STI) are supported:\r\n\r\n1. Create a db migration that adds a String ```type``` column to your model\r\n2. Subclass the model class. You only need to add ```acts_as_tree``` to your base class:\r\n\r\n```ruby\r\nclass Tag < ActiveRecord::Base\r\n  acts_as_tree\r\nend\r\nclass WhenTag < Tag ; end\r\nclass WhereTag < Tag ; end\r\nclass WhatTag < Tag ; end\r\n```\r\n\r\n## Deterministic ordering\r\n\r\nBy default, children will be ordered by your database engine, which may not be what you want.\r\n\r\nIf you want to order children alphabetically, and your model has a ```name``` column, you'd do this:\r\n\r\n```ruby\r\nclass Tag < ActiveRecord::Base\r\n  acts_as_tree :order => 'name'\r\nend\r\n```\r\n\r\nIf you want a specific order, add a new integer column to your model in a migration:\r\n\r\n```ruby\r\nt.integer :sort_order\r\n```\r\n\r\nand in your model:\r\n\r\n```ruby\r\nclass OrderedTag < ActiveRecord::Base\r\n  acts_as_tree :order => 'sort_order'\r\nend\r\n```\r\n\r\nWhen you enable ```order```, you'll also have the following new methods injected into your model:\r\n\r\n* ```tag.siblings_before``` is a scope containing all nodes with the same parent as ```tag```,\r\n  whose sort order column is less than ```self```. These will be ordered properly, so the ```last```\r\n  element in scope will be the sibling immediately before ```self```\r\n* ```tag.siblings_after``` is a scope containing all nodes with the same parent as ```tag```,\r\n  whose sort order column is more than ```self```. These will be ordered properly, so the ```first```\r\n  element in scope will be the sibling immediately \"after\" ```self```\r\n\r\nIf your ```order``` column is an integer attribute, you'll also have these:\r\n\r\n* ```node1.self_and_descendants_preordered``` which will return descendants,\r\n  [pre-ordered](http://en.wikipedia.org/wiki/Tree_traversal#Pre-order).\r\n\r\n* ```node1.prepend_sibling(node2)``` which will\r\n  1. set ```node2``` to the same parent as ```node1```,\r\n  2. set ```node2```'s order column to 1 less than ```node1```'s value, and\r\n  3. decrement the order_column of all children of node1's parents whose order_column is <>>= node2's new value by 1.\r\n\r\n* ```node1.append_sibling(node2)``` which will\r\n  1. set ```node2``` to the same parent as ```node1```,\r\n  2. set ```node2```'s order column to 1 more than ```node1```'s value, and\r\n  3. increment the order_column of all children of node1's parents whose order_column is >= node2's new value by 1.\r\n\r\n```ruby\r\n\r\nroot = OrderedTag.create(:name => \"root\")\r\na = OrderedTag.create(:name => \"a\", :parent => \"root\")\r\nb = OrderedTag.create(:name => \"b\")\r\nc = OrderedTag.create(:name => \"c\")\r\n\r\n# We have to call 'root.reload.children' because root won't be in sync with the database otherwise:\r\n\r\na.append_sibling(b)\r\nroot.reload.children.collect(&:name)\r\n=> [\"a\", \"b\"]\r\n\r\na.prepend_sibling(b)\r\nroot.reload.children.collect(&:name)\r\n=> [\"b\", \"a\"]\r\n\r\na.append_sibling(c)\r\nroot.reload.children.collect(&:name)\r\n=> [\"b\", \"a\", \"c\"]\r\n\r\nb.append_sibling(c)\r\nroot.reload.children.collect(&:name)\r\n=> [\"b\", \"c\", \"a\"]\r\n```\r\n\r\n## Concurrency\r\n\r\nSeveral methods, especially ```#rebuild``` and ```#find_or_create_by_path```, cannot run concurrently correctly.\r\n```#find_or_create_by_path```, for example, may create duplicate nodes.\r\n\r\nDatabase row-level locks work correctly with PostgreSQL, but MySQL's row-level locking is broken, and\r\nerroneously reports deadlocks where there are none. To work around this, and have a consistent implementation\r\nfor both MySQL and PostgreSQL, [with_advisory_lock](https://github.com/mceachen/with_advisory_lock)\r\nis used automatically to ensure correctness.\r\n\r\nIf you are already managing concurrency elsewhere in your application, and want to disable the use\r\nof with_advisory_lock, pass ```:with_advisory_lock => false``` in the options hash:\r\n\r\n```ruby\r\nclass Tag\r\n  acts_as_tree :with_advisory_lock => false\r\nend\r\n```\r\n\r\nNote that you *will eventually have data corruption* if you disable advisory locks, write to your\r\ndatabase with multiple threads, and don't provide an alternative mutex.\r\n\r\n\r\n## FAQ\r\n\r\n### Does this gem support multiple parents?\r\n\r\nNo. This gem's API is based on the assumption that each node has either 0 or 1 parent.\r\n\r\nThe underlying closure tree structure will support multiple parents, but there would be many\r\nbreaking-API changes to support it. I'm open to suggestions and pull requests.\r\n\r\n### How do I use this with test fixtures?\r\n\r\nTest fixtures aren't going to be running your ```after_save``` hooks after inserting all your\r\nfixture data, so you need to call ```.rebuild!``` before your test runs. There's an example in\r\nthe spec ```tag_spec.rb```:\r\n\r\n```ruby\r\n  describe \"Tag with fixtures\" do\r\n    fixtures :tags\r\n    before :each do\r\n      Tag.rebuild! # <- required if you use fixtures\r\n    end\r\n```\r\n\r\n**However, if you're just starting with Rails, may I humbly suggest you adopt a factory library**,\r\nrather than using fixtures? [Lots of people have written about this already](https://www.google.com/search?q=fixtures+versus+factories).\r\n\r\n\r\n## Testing\r\n\r\nClosure tree is [tested under every combination](http://travis-ci.org/#!/mceachen/closure_tree) of\r\n\r\n* Ruby 1.8.7 and Ruby 1.9.3\r\n* The latest Rails 3.0, 3.1, and 3.2 branches, and\r\n* MySQL and PostgreSQL. SQLite works in a single-threaded environment.\r\n\r\nAssuming you're using [rbenv](https://github.com/sstephenson/rbenv), you can use ```tests.sh``` to\r\nrun the test matrix locally.\r\n\r\nParallelism is not tested with Rails 3.0.x nor 3.1.x due to this\r\n[known issue](https://github.com/rails/rails/issues/7538).\r\n\r\n## Change log\r\n\r\n### 3.8.1\r\n\r\n* Double-check locking for find_or_create_by_path\r\n\r\n### 3.8.0\r\n\r\n* Support for preordered descendants. This requires a numeric sort order column.\r\n  Resolves [feature request 38](https://github.com/mceachen/closure_tree/issues/38).\r\n* Moved modules from ```acts_as_tree``` into separate files\r\n\r\n### 3.7.3\r\n\r\nDue to MySQL's inability to lock rows properly, I've switched to advisory_locks for\r\nall write paths. This will prevent deadlocks, addressing\r\n[issue 41](https://github.com/mceachen/closure_tree/issues/41).\r\n\r\n### 3.7.2\r\n\r\n* Support for UUID primary keys. Addresses\r\n  [issue 40](https://github.com/mceachen/closure_tree/issues/40). Thanks for the pull request,\r\n  [Julien](https://github.com/calexicoz)!\r\n\r\n### 3.7.1\r\n\r\n* Moved requires into ActiveSupport.on_load\r\n* Added ```require 'with_advisory_lock'```\r\n\r\n### 3.7.0\r\n\r\n**Thread safety!**\r\n* [Advisory locks](https://github.com/mceachen/with_advisory_lock) were\r\n  integrated with the class-level ```find_or_create_by_path``` and ```rebuild!```.\r\n* Pessimistic locking is used by the instance-level ```find_or_create_by_path```.\r\n\r\n### 3.6.9\r\n\r\n* [Don Morrison](https://github.com/elskwid) massaged the [#hash_tree](#nested-hashes) query to\r\nbe more efficient, and found a bug in ```hash_tree```'s query that resulted in duplicate rows,\r\nwasting time on the ruby side.\r\n\r\n### 3.6.7\r\n\r\n* Added workaround for ActiveRecord::Observer usage pre-db-creation. Addresses\r\n  [issue 32](https://github.com/mceachen/closure_tree/issues/32).\r\n  Thanks, [Don Morrison](https://github.com/elskwid)!\r\n\r\n### 3.6.6\r\n\r\n* Added support for Rails 4's [strong parameter](https://github.com/rails/strong_parameters).\r\nThanks, [James Miller](https://github.com/bensie)!\r\n\r\n### 3.6.5\r\n\r\n* Use ```quote_table_name``` instead of ```quote_column_name```. Addresses\r\n [issue 29](https://github.com/mceachen/closure_tree/issues/29). Thanks,\r\n [Marcello Barnaba](https://github.com/vjt)!\r\n\r\n### 3.6.4\r\n\r\n* Use ```.pluck``` when available for ```.ids_from```. Addresses\r\n [issue 26](https://github.com/mceachen/closure_tree/issues/26). Thanks,\r\n [Chris Sturgill](https://github.com/sturgill)!\r\n\r\n### 3.6.3\r\n\r\n* Fixed [issue 24](https://github.com/mceachen/closure_tree/issues/24), which optimized ```#hash_tree```\r\n  for roots. Thanks, [Saverio Trioni](https://github.com/rewritten)!\r\n\r\n### 3.6.2\r\n\r\n* Fixed [issue 23](https://github.com/mceachen/closure_tree/issues/23), which added support for ```#siblings```\r\n  when sort_order wasn't specified. Thanks, [Gary Greyling](https://github.com/garygreyling)!\r\n\r\n### 3.6.1\r\n\r\n* Fixed [issue 20](https://github.com/mceachen/closure_tree/issues/20), which affected\r\n  deterministic ordering when siblings where different STI classes. Thanks, [edwinramirez](https://github.com/edwinramirez)!\r\n\r\n### 3.6.0\r\n\r\nAdded support for:\r\n* ```:hierarchy_class_name``` as an option\r\n* ActiveRecord::Base.table_name_prefix\r\n* ActiveRecord::Base.table_name_suffix\r\n\r\nThis addresses [issue 21](https://github.com/mceachen/closure_tree/issues/21). Thanks, [Judd Blair](https://github.com/juddblair)!\r\n\r\n### 3.5.2\r\n\r\n* Added ```find_all_by_generation```\r\n  for [feature request 17](https://github.com/mceachen/closure_tree/issues/17).\r\n\r\n### 3.4.2\r\n\r\n* Fixed [issue 18](https://github.com/mceachen/closure_tree/issues/18), which affected\r\n  append_node/prepend_node ordering when the first node didn't have an explicit order_by value\r\n\r\n### 3.4.1\r\n\r\n* Reverted .gemspec mistake that changed add_development_dependency to add_runtime_dependency\r\n\r\n### 3.4.0\r\n\r\nFixed [issue 15](https://github.com/mceachen/closure_tree/issues/15):\r\n* \"parent\" is now attr_accessible, which adds support for constructor-provided parents.\r\n* updated readme accordingly\r\n\r\n### 3.3.2\r\n\r\n* Merged calebphillips' patch for a more efficient leaves query\r\n\r\n### 3.3.1\r\n\r\n* Added support for partially-unsaved hierarchies [issue 13](https://github.com/mceachen/closure_tree/issues/13):\r\n```\r\na = Tag.new(name: \"a\")\r\nb = Tag.new(name: \"b\")\r\na.children << b\r\na.save\r\n```\r\n\r\n### 3.3.0\r\n\r\n* Added [```hash_tree```](#nested-hashes).\r\n\r\n### 3.2.1\r\n\r\n* Added ```ancestor_ids```, ```descendant_ids```, and ```sibling_ids```\r\n* Added example spec to solve [issue 9](https://github.com/mceachen/closure_tree/issues/9)\r\n\r\n### 3.2.0\r\n\r\n* Added support for deterministic ordering of nodes.\r\n\r\n### 3.1.0\r\n\r\n* Switched to using ```has_many :though``` rather than ```has_and_belongs_to_many```\r\n\r\n### 3.0.4\r\n\r\n* Merged [pull request](https://github.com/mceachen/closure_tree/pull/8) to fix ```.siblings``` and ```.self_and_siblings```\r\n  (Thanks, [eljojo](https://github.com/eljojo)!)\r\n\r\n### 3.0.3\r\n\r\n* Added support for ActiveRecord's whitelist_attributes\r\n  (Make sure you read [the Rails Security Guide](http://guides.rubyonrails.org/security.html), and\r\n  enable ```config.active_record.whitelist_attributes``` in your ```config/application.rb``` ASAP!)\r\n\r\n### 3.0.2\r\n\r\n* Fix for ancestry-loop detection (performed by a validation, not through raising an exception in before_save)\r\n\r\n### 3.0.1\r\n\r\n* Support 3.2.0's fickle deprecation of InstanceMethods (Thanks, [jheiss](https://github.com/mceachen/closure_tree/pull/5))!\r\n\r\n### 3.0.0\r\n\r\n* Support for polymorphic trees\r\n* ```find_by_path``` and ```find_or_create_by_path``` signatures changed to support constructor attributes\r\n* tested against Rails 3.1.3\r\n\r\n### 2.0.0\r\n\r\n* Had to increment the major version, as rebuild! will need to be called by prior consumers to support the new ```leaves``` class and instance methods.\r\n* Tag deletion is supported now along with ```:dependent => :destroy``` and ```:dependent => :delete_all```\r\n* Switched from default rails plugin directory structure to rspec\r\n* Support for running specs under different database engines: ```export DB ; for DB in sqlite3 mysql postgresql ; do rake ; done```\r\n\r\n## Thanks to\r\n\r\n* https://github.com/collectiveidea/awesome_nested_set\r\n* https://github.com/patshaughnessy/class_factory\r\n* JetBrains, which provides an [open-source license](http://www.jetbrains.com/ruby/buy/buy.jsp#openSource) to\r\n  [RubyMine](http://www.jetbrains.com/ruby/features/) for the development of this project.\r\n","google":"UA-38750440-1","note":"Don't delete this file! It's used internally to help with page regeneration."}