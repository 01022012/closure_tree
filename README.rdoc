= Closure Tree

Closure Tree is a mostly-API-compatible replacement for the
acts_as_tree and awesome_nested_set gems, but with much better
mutation performance thanks to the Closure Tree storage algorithm.

See {Bill Karwin}[http://karwin.blogspot.com/]'s excellent
{Models for hierarchical data presentation}[http://www.slideshare.net/billkarwin/models-for-hierarchical-data]
for a description of different tree storage algorithms.

== Setup

Note that closure_tree is being developed for Rails 3.1.0.beta1

1.  Add this to your Gemfile: <code>gem 'closure_tree'</code>

2.  Run <code>bundle install</code>

3.  Add <code>acts_as_tree</code> to your hierarchical model(s)

4.  Add a <code>parent_id</code> column to your hierarchical model, if it doesn't already have one.

    If the column is null, the tag will be considered a root node. 

      class AddParentIdToTag < ActiveRecord::Migration
        def change
          add_column :tag, :parent_id, :integer
        end
      end

5.  Add a database migration to store the hierarchy for your model. By
    convention the table name will be the model's table name, followed by
    "_hierarchy":
      class CreateTagHierarchy < ActiveRecord::Migration
        def change
          create_table :tags_hierarchy do |t|
            t.integer  :ancestor_id, :null => false   # ID of the parent/grandparent/great-grandparent/... tag
            t.integer  :descendant_id, :null => false # ID of the target tag
            t.integer  :generations, :null => false   # Number of generations between the ancestor and the descendant. Parent/child = 1, for example.
          end

          # For "all progeny of..." selects:
          add_index :tags_hierarchy, [:ancestor_id, :descendant_id], :unique => true

          # For "all ancestors of..." selects
          add_index :tags_hierarchy, [:descendant_id]
        end
      end

6.  Run <code>rake db:migrate</code>

7.  If you're migrating away from another system where your model already has a code>parent_id</code> column, run
    <code>Tag.rebuild!</code> and the _hierarchy table will be rebuilt.

    If you're starting from scratch with no prior data, you don't need to call rebuild, as long as you remember
    to use the <code>add_child</code> or <code>move_to_child_of</code> methods.

== Usage

<em>Based on {Bear Den Design's post}[http://beardendesigns.com/blogs/permalink/56], just with less {Ella}[http://www.flickr.com/photos/ecbearden/3284964622/] </em>

=== Creation

Create a root node:

  science = Tag.create!(:name => 'Science')

Put a new thing inside this root node:

  physics = Tag.create!(:name => 'Physics')
  science.add_child physics

Put another thing inside the "physics" node:

  gravity = Tag.create!(:name => 'Gravity')
  physics.add_child gravity

Now you should have something that resembles this:

* science
  * physics
    * gravity

=== Advanced Usage

Accessing levels without a hit to the db:

  Tag.each_with_level(Tag.root.self_and_descendants) do |Tag, level|
    ...
  end

== Accessing Data

=== Class methods

[Tag.root] returns an arbitrary root node
[Tag.roots] returns all root nodes

=== Instance methods

[tag.root] returns the root for this node
[tag.level] returns the level, or "generation", for this node in the tree. A root node = 0
[tag.parent] returns the node's immediate parent
[tag.children] returns an array of immediate children (just those in the next level).
[tag.ancestors] returns an array of all parents, parents' parents, etc, excluding self.
[tag.self_and_ancestors] returns an array of all parents, parents' parents, etc, including self.
[tag.siblings] returns an array of brothers and sisters (all at that level), excluding self.
[tag.self_and_siblings] returns an array of brothers and sisters (all at that level), including self.
[tag.descendants] returns an array of all children, childrens' children, etc., excluding self.
[tag.self_and_descendants] returns an array of all children, childrens' children, etc., including self.
[tag.leaves] returns an array of all descendants that have no children.

=== Predicate instance methods (these don't hit the DB)

[tag.root?] returns true if this is a root node
[tag.child?] returns true if this is a child node. It has a parent.
[tag.is_ancestor_of?(obj)] returns  true if nested by any obj
[tag.is_or_is_ancestor_of?(obj)] returns  true if nested by any obj or self is obj
[tag.is_descendant_of?(obj)] returns  true if self is nested under obj
[tag.is_or_is_descendant_of?(obj)] returns  true if self is nested under obj or self is obj
[tag.leaf?] returns  true if this is a leaf node. It has no children.
